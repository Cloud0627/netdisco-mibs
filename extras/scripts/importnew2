#!/usr/bin/env perl
# diff_dir [new_dir]
# will look into new_dir for MIBs to add or replace in MIBHOME/...

use strict;
use warnings;

use charnames ':full';
binmode STDOUT, ':utf8';

use List::Util 'max';
use File::Temp;
use File::Copy;
use File::Spec::Functions qw(splitdir catfile);
use Term::ANSIColor qw(:constants);

if (!defined $ENV{MIBHOME}) {
  print "error: must define \$MIBHOME (where the MIB dirs live)\n";
  exit(1);
}

$ENV{SNMPCONFPATH} = '';
$ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";
$ENV{MIBS} = 'SNMPv2-MIB';
$ENV{MIBDIRS} = "$ENV{MIBHOME}/net-snmp:$ENV{MIBHOME}/rfc:$ENV{MIBHOME}/cisco";

my $from = shift;
if (!defined $from or not -d $from) {
  print "usage: $0 new_dir (named same as old_dir and containing new MIBs)\n";
  exit(1);
}

my $diffcmd = 'diff -bBN';
my $vendor = (grep {m/\S/} splitdir($from))[-1];

my $to = catfile($ENV{MIBHOME}, $vendor);
if (! -d $to) {
  print "error: no directory in MIBHOME named $vendor\n";
  exit(1);
}

# let net-snmp find MIBs in the new bundle
my $tmpdir = File::Temp->newdir();
$ENV{SNMP_PERSISTENT_DIR} = $tmpdir->dirname;
qx(snmptranslate -IR sysName 2>&1 >/dev/null);
my $newmibdirs = $ENV{MIBDIRS} .":$from";
qx(snmptranslate -M'$newmibdirs' -IR sysName 2>\&1 >/dev/null);
$ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";

# read the MIBs that net-snmp likes (file '3' is new_dir vendor)
my (%mib_for, %file_for);
open(my $cache, '<', "$tmpdir/mib_indexes/3") or die $!;

while (my $line = <$cache>) {
  next if $line =~ m/^DIR /;
  my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);

  # store mib-file mapping
  $mib_for{$file} = $mib;
  $file_for{$mib} = $file;
}

close $cache;
undef $tmpdir;
my $bail = 0;

foreach my $mib (sort keys %file_for) {
  # check no MIB is featured in another vendor's bundle
  my @cache = qx(egrep -m1 -i '^$mib ' $ENV{SNMP_PERSISTENT_DIR}/cache/*);
  foreach my $hit (@cache) {
    my ($cachefile, $oldfile) = ($hit =~ m/^([^:]+):$mib\s+(\S+)$/);
    my $header = qx(head -1 $cachefile);
    my ($owner) = ($header =~ m#{{mibhome}}/(\w+)$#);

    if ($vendor ne $owner) {
      ++$bail;

      # Look for version numbers - https://tools.ietf.org/html/rfc2578
      my $oldv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' '$ENV{MIBHOME}/$owner/$oldfile')
        =~ m/"(\d{10}|\d{12})Z"/g);
      my $newv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' '$from/$file_for{$mib}')
        =~ m/"(\d{10}|\d{12})Z"/g);

      print RED, "\N{HEAVY BALLOT X} ", MAGENTA, uc($mib), CYAN;

      if ($oldv and $newv) {
        $oldv = "20$oldv" if length($oldv) == 10;
        $newv = "20$newv" if length($newv) == 10;

        if ($oldv < $newv) {
          print " (in '$file_for{$mib}') is within vendor ",
          MAGENTA, $owner, CYAN, " and newer ($newv > $oldv)\n", RESET;
        }
        elsif ($oldv > $newv) {
          print " (in '$file_for{$mib}') is within vendor ",
          MAGENTA, $owner, CYAN, " but older ($newv < $oldv)\n", RESET;
        }
        else {
          print " (in '$file_for{$mib}') is within vendor ",
          MAGENTA, $owner, CYAN, " and the same revision\n", RESET;
        }
      }
      else {
        print " (in '$file_for{$mib}') is already featured within vendor ",
        MAGENTA, "$owner\n", RESET;
      }
    }
  }

  # check for multiple MIB defs within one file (net-snmp cannot detect)
  my $mibfile = catfile($from, $file_for{$mib});
  my @defs = qx(egrep '^\\s*\\w(\\w|-)+\\s+DEFINITIONS\\s*::=\\s*BEGIN' $mibfile);
  if (scalar @defs > 1) {
    ++$bail;
    print RED, "\N{HEAVY BALLOT X} ", CYAN, 'file ', MAGENTA, $file_for{$mib},
      CYAN, " defines multiple MIBs\n", RESET;
  }
}

if ($bail) {
  print "\N{CLOCKWISE GAPPED CIRCLE ARROW} No action taken.\n";
  exit(1);
}

# TODO: need to compare MIB not filename!!
# that is, each MIB in new_dir that is not in cache of the vendor
foreach my $file (sort keys %mib_for) {
    my $newfile = catfile($from, $file);
    my $oldfile = catfile($to, $file);

    if (! -e $oldfile) {
        print GREEN,
          "\N{BLACK SMALL STAR} ",
          "\N{BALLOT BOX WITH X} ",
          "\N{BLACK STAR} ",
          "\N{NEXT PAGE} ",
          "\N{HEAVY CHECK MARK} ",
          "\N{RIGHTWARDS WHITE ARROW FROM WALL} ",
          "\N{UPPER LEFT QUADRANT CIRCULAR ARC} ",
          "\N{LOWER RIGHT QUADRANT CIRCULAR ARC} ",
          "$mib_for{$file} \N{HEAVY WIDE-HEADED RIGHTWARDS ARROW} $vendor\n", RESET;
        # copy($newfile, $to) or die $!;
    }
    else {
        my $diff = qx($diffcmd $oldfile $newfile);
        if ($diff !~ m/^\s*$/) {
            # Look for version numbers - https://tools.ietf.org/html/rfc2578
            my $oldv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' $oldfile)
              =~ m/"(\d{10}|\d{12})Z"/g);
            my $newv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' $newfile)
              =~ m/"(\d{10}|\d{12})Z"/g);

            next if $newv <= $oldv;
            # or NEXT PAGE
            print YELLOW, "$file \N{HEAVY WIDE-HEADED RIGHTWARDS ARROW} $vendor ($newv > $oldv)\n", RESET;
            # copy($newfile, $to) or die $!;
        }
        else {
            print BLUE, "$file \N{HEAVY CHECK MARK}\n", RESET;
        }
    }
}

exit(0);
