#!/usr/bin/env perl
# genxlate [vendor|*] - run snmptranslate on MIBs and save output
# no param will make one report for all MIBs

use strict;
use warnings;

use charnames ':full';
binmode STDOUT, ':utf8';
$|++;

use Time::HiRes 'sleep';
use File::Temp;
use File::Spec::Functions qw(splitdir catfile);
use Term::ANSIColor qw(:constants);
use POSIX qw(:sys_wait_h);

if (!defined $ENV{MIBHOME}) {
  print "error: must define \$MIBHOME (where the MIB dirs live)\n";
  exit(1);
}

$ENV{SNMPCONFPATH} = '';
$ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";
$ENV{MIBS} = 'SNMPv2-MIB';

my @mibdirs = grep { -d and $_ !~ m#/extras$# } glob("$ENV{MIBHOME}/*");
$ENV{MIBDIRS} = join ':', @mibdirs;

my $indexfile = catfile($ENV{SNMP_PERSISTENT_DIR}, 'mib_index2.txt');
if (! -f $indexfile) {
  print "error: missing mib_index2.txt (run mkcache then mkindex)\n";
  exit(1);
}

# load mib_index2.txt mapping all current known MIBs
my (%mibs_for, $currvendor);
open(my $index, '<', $indexfile) or die $!;
while (my $line = <$index>) {
  next if $line =~ m/^MIB Index/ or $line =~ m/^\s*$/;
  if ($line =~ m/^DIR\s+(\S+)/) {
    $currvendor = (grep {m/\S/} splitdir($1))[-1];
    next;
  }
  my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);
  push @{$mibs_for{$currvendor}}, $mib;
}
close $index;

my $vendor = shift;
if ($vendor and !exists $mibs_for{$vendor} and $vendor ne '*') {
  print "error: vendor arg must exist in MIBHOME\n";
  exit(1);
}
my @vendors = (defined $vendor)
  ? (($vendor eq '*') ? (sort keys %mibs_for) : ($vendor))
  : ('all');

foreach my $v (@vendors) {
  my $mibs = ($v eq 'all') ? 'ALL' : (join ':', @{$mibs_for{$v}});
  my $out = catfile($ENV{MIBHOME}, 'extras', 'reports', $v);
  my $err = File::Temp->new();

  defined(my $pid = fork) or die "Couldn't fork: $!";
  if (!$pid) { # Child
    exec(qq{snmptranslate -Tt -Le -m $mibs 2>$err | perl -p -e 's/ tc=[0-9]+//g' 1>$out})
      or die "Couldn't exec: $!";
  } else { # Parent
    while (! waitpid($pid, WNOHANG)) {
      &status("Parsing $v");
      sleep 0.05;
    }
  }

  if (-s $err) {
    print "\r\e[K"; # blank line
    print RED, "\N{HEAVY BALLOT X} ", CYAN, 'Errors from ',
      MAGENTA, $v, CYAN, " MIBs\n", RESET;
    while (<$err>) { print }
    print "\n";
  }
}

print "\r\e[K"; # blank line
print "\N{BLACK FLAG} Reports complete.\n";
exit(0);

my $i = undef;
sub status {
  my $note = (shift || '');
  my %spinner = (
    "\N{BRAILLE PATTERN DOTS-2345678}" => "\N{BRAILLE PATTERN DOTS-1235678}",
    "\N{BRAILLE PATTERN DOTS-1235678}" => "\N{BRAILLE PATTERN DOTS-1234678}",
    "\N{BRAILLE PATTERN DOTS-1234678}" => "\N{BRAILLE PATTERN DOTS-1234578}",
    "\N{BRAILLE PATTERN DOTS-1234578}" => "\N{BRAILLE PATTERN DOTS-1234567}",
    "\N{BRAILLE PATTERN DOTS-1234567}" => "\N{BRAILLE PATTERN DOTS-1234568}",
    "\N{BRAILLE PATTERN DOTS-1234568}" => "\N{BRAILLE PATTERN DOTS-1245678}",
    "\N{BRAILLE PATTERN DOTS-1245678}" => "\N{BRAILLE PATTERN DOTS-1345678}",
    "\N{BRAILLE PATTERN DOTS-1345678}" => "\N{BRAILLE PATTERN DOTS-2345678}"
  );
  $i = (!defined $i) ? "\N{BRAILLE PATTERN DOTS-2345678}" : $spinner{$i};
  print "\r\e[K"; # blank line
  print YELLOW, "$i ", CYAN, $note, RESET;
}
