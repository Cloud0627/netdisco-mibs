#!/usr/bin/env perl
# mibcheck [new_dir]
# sanity checks on the MIBs in new_dir
# - show MIBs already 'owned' by another vendor
# - note whether already-owend mib is newer and could be imported
# - alert to multiple MIBs defined in a file
# - warning about files in new_dir that will be ignored

use strict;
use warnings;

use charnames ':full';
binmode STDOUT, ':utf8';

use List::Util 'max';
use File::Temp;
use File::Spec::Functions qw(splitdir catfile);
use Term::ANSIColor qw(:constants);

if (!defined $ENV{MIBHOME}) {
  print "error: must define \$MIBHOME (where the MIB dirs live)\n";
  exit(1);
}

$ENV{SNMPCONFPATH} = '';
$ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";
$ENV{MIBS} = 'SNMPv2-MIB';
$ENV{MIBDIRS} = "$ENV{MIBHOME}/net-snmp:$ENV{MIBHOME}/rfc:$ENV{MIBHOME}/cisco";

my $from = shift;
if (!defined $from or not -d $from) {
  print "usage: $0 new_dir (named same as old_dir and containing new MIBs)\n";
  exit(1);
}

my $vendor = (grep {m/\S/} splitdir($from))[-1];

my $to = catfile($ENV{MIBHOME}, $vendor);
if (! -d $to) {
  print "error: no directory in MIBHOME named $vendor\n";
  exit(1);
}

my $indexfile = catfile($ENV{SNMP_PERSISTENT_DIR}, 'mib_index2.txt');
if (! -f $indexfile) {
  print "error: missing mib_index2.txt (run mkcache then mkindex)\n";
  exit(1);
}

# load mib_index2.txt mapping all current known MIBs
my (%vendor_for, %oldfile_for, $currvendor);
open(my $index, '<', $indexfile) or die $!;
while (my $line = <$index>) {
  next if $line =~ m/^MIB Index/ or $line =~ m/^\s*$/;
  if ($line =~ m/^DIR\s+(\S+)/) {
    $currvendor = (grep {m/\S/} splitdir($1))[-1];
    next;
  }
  my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);

  # store mib-vendor mapping
  if (exists $vendor_for{$mib}) {
    print YELLOW, "\N{WARNING SIGN} ", MAGENTA, uc($mib), CYAN,
      "is duplicated in vendors $vendor_for{$mib} and $currvendor\n", RESET;
  }
  $vendor_for{$mib}  = $currvendor;
  $oldfile_for{$mib} = $file;
}
close $index;

# let net-snmp find MIBs in the new bundle
my ($mib_for, $file_for) = build_index($from);

my $bail = 0;
my %newfiles = map  {($_ => 1)}
               map  {(splitdir($_))[-1]}
               grep {-f} glob(catfile($from, '*'));

foreach my $mib (sort keys %{$file_for}) {
  my $mibfile = catfile($from, $file_for->{$mib});
  delete $newfiles{ $file_for->{$mib} };
  &status($mib);

  # check no MIB is featured in another vendor's bundle
  if (exists $vendor_for{$mib} and $vendor_for{$mib} ne $vendor) {
    ++$bail;
    print "\r\e[K"; # blank line
    print RED, "\N{HEAVY BALLOT X} ", MAGENTA, uc($mib), CYAN;
    my $owner = $vendor_for{$mib};

    # Look for version numbers - https://tools.ietf.org/html/rfc2578
    # this is a gesture to the maintainer in case there's a newer version
    my $oldv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' '$ENV{MIBHOME}/$owner/$oldfile_for{$mib}')
      =~ m/"(\d{10}|\d{12})Z"/g);
    my $newv = max(qx(egrep -A1 '(REVISION|LAST-UPDATED)' '$mibfile')
      =~ m/"(\d{10}|\d{12})Z"/g);

    if ($oldv and $newv) {
      $oldv = "20$oldv" if length($oldv) == 10;
      $newv = "20$newv" if length($newv) == 10;

      if ($oldv < $newv) {
        print " (in '", $file_for->{$mib}, "') is within vendor ",
        MAGENTA, $owner, CYAN, " and newer ($newv > $oldv)\n", RESET;
      }
      elsif ($oldv > $newv) {
        print " (in '", $file_for->{$mib}, "') is within vendor ",
        MAGENTA, $owner, CYAN, " but older ($newv < $oldv)\n", RESET;
      }
      else {
        print " (in '", $file_for->{$mib}, "') is within vendor ",
        MAGENTA, $owner, CYAN, " and the same revision\n", RESET;
      }
    }
    else {
      print " (in '", $file_for->{$mib},
      "') is already featured within vendor ", MAGENTA, "$owner\n", RESET;
    }
  }

  # check for multiple MIB defs within one file (net-snmp cannot detect)
  my @defs = qx(egrep '^\\s*\\w(\\w|-)+\\s+DEFINITIONS\\s*::=\\s*BEGIN' $mibfile);
  if (scalar @defs > 1) {
    ++$bail;
    print "\r\e[K"; # blank line
    print RED, "\N{HEAVY BALLOT X} ", CYAN, 'file ', MAGENTA, $file_for->{$mib},
      CYAN, " defines multiple MIBs\n", RESET;
  }
}

print "\r\e[K"; # blank line

# show files being ignored by this script
foreach my $file (sort keys %newfiles) {
  print YELLOW, "\N{WARNING SIGN} ", CYAN, 'file ', MAGENTA,
    $file, CYAN, " is not a MIB\n", RESET;
}

if ($bail) {
  print "\N{BLACK FLAG} Checks done, with errors.\n";
  exit(1);
}
else {
  print "\N{HEAVY CHECK MARK} Sanity checks passed.\n";
  exit(0);
}

sub build_index {
  my $bundle = shift;
  my (%mib_for, %file_for);

  my $tmpdir = File::Temp->newdir();
  $ENV{SNMP_PERSISTENT_DIR} = $tmpdir->dirname;
  qx(snmptranslate -IR sysName 2>&1 >/dev/null);
  my $newmibdirs = $ENV{MIBDIRS} .":$bundle";
  qx(snmptranslate -M'$newmibdirs' -IR sysName 2>\&1 >/dev/null);
  $ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";

  # read the MIBs that net-snmp likes (file '3' is the vendor)
  open(my $cache, '<', "$tmpdir/mib_indexes/3") or die $!;
  while (my $line = <$cache>) {
    next if $line =~ m/^DIR /;
    my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);

    # store mib-file mapping
    $mib_for{$file} = $mib;
    $file_for{$mib} = $file;
  }
  close $cache;

  return (\%mib_for, \%file_for);
}

my $i = undef;
sub status {
  my $note = (shift || '');
  my %spinner = (
    "\N{BRAILLE PATTERN DOTS-2345678}" => "\N{BRAILLE PATTERN DOTS-1235678}",
    "\N{BRAILLE PATTERN DOTS-1235678}" => "\N{BRAILLE PATTERN DOTS-1234678}",
    "\N{BRAILLE PATTERN DOTS-1234678}" => "\N{BRAILLE PATTERN DOTS-1234578}",
    "\N{BRAILLE PATTERN DOTS-1234578}" => "\N{BRAILLE PATTERN DOTS-1234567}",
    "\N{BRAILLE PATTERN DOTS-1234567}" => "\N{BRAILLE PATTERN DOTS-1234568}",
    "\N{BRAILLE PATTERN DOTS-1234568}" => "\N{BRAILLE PATTERN DOTS-1245678}",
    "\N{BRAILLE PATTERN DOTS-1245678}" => "\N{BRAILLE PATTERN DOTS-1345678}",
    "\N{BRAILLE PATTERN DOTS-1345678}" => "\N{BRAILLE PATTERN DOTS-2345678}"
  );
  $i = (!defined $i) ? "\N{BRAILLE PATTERN DOTS-2345678}" : $spinner{$i};
  print "\r\e[K"; # blank line
  print YELLOW, "$i ", CYAN, $note, RESET;
}
