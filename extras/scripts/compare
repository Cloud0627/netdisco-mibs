#!/usr/bin/env perl
# compare new_mib_file
# will run a diff against the version of the same MIB in netdisco-mibs

use strict;
use warnings;

use File::Temp;
use File::Basename;
use File::Spec::Functions qw(splitdir catfile);

if (!defined $ENV{MIBHOME}) {
  print "error: must define \$MIBHOME (where the MIB dirs live)\n";
  exit(1);
}

$ENV{SNMPCONFPATH} = '';
$ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";
$ENV{MIBS} = 'SNMPv2-MIB';
$ENV{MIBDIRS} = "$ENV{MIBHOME}/net-snmp:$ENV{MIBHOME}/rfc:$ENV{MIBHOME}/cisco";

# make an index so that net-snmp tells us what MIB is in the file
my $newmib = shift;
if (!defined $newmib or not -f $newmib) {
  print "usage: $0 new_mib_file\n";
  exit(1);
}

# find the MIB name
my ($newfile, $newdir, undef) = fileparse($newmib);
my ($mib_for, $file_for) = build_index($newdir);
if (!exists $mib_for->{$newfile}) {
  print "error: net-snmp unable to parse $newfile as a MIB\n";
  exit(1);
}

# find the file in netdisco-mibs with the same MIB
my $mib = $mib_for->{$newfile};
my ($vendor_for, $oldfile_for) = parse_index2();
if (!exists $vendor_for->{$mib} or !exists $oldfile_for->{$mib}) {
  print "error: MIB $mib is unknown to netdisco-mibs (run mkindex?)\n";
  exit(1);
}

# run a diff
my $oldmib = catfile($ENV{MIBHOME}, $vendor_for->{$mib}, $oldfile_for->{$mib});
exec(qq{diff -b -B -w $oldmib $newmib | less});

# -- exit(0)

sub build_index {
  my $bundle = shift;
  my (%mib_for, %file_for);

  my $tmpdir = File::Temp->newdir();
  $ENV{SNMP_PERSISTENT_DIR} = $tmpdir->dirname;
  qx(snmptranslate -IR sysName 2>&1 >/dev/null);
  my $newmibdirs = $ENV{MIBDIRS} .":$bundle";
  qx(snmptranslate -M'$newmibdirs' -IR sysName 2>\&1 >/dev/null);
  $ENV{SNMP_PERSISTENT_DIR} = "$ENV{MIBHOME}/extras/indexes";

  # read the MIBs that net-snmp likes (file '3' is the vendor)
  # TODO: make this work also for rfc:net-snmp
  open(my $cache, '<', "$tmpdir/mib_indexes/3") or die $!;
  while (my $line = <$cache>) {
    next if $line =~ m/^DIR /;
    my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);

    # store mib-file mapping
    $mib_for{$file} = $mib;
    $file_for{$mib} = $file;
  }
  close $cache;

  return (\%mib_for, \%file_for);
}

sub parse_index2 {
  my $indexfile = catfile($ENV{SNMP_PERSISTENT_DIR}, 'mib_index2.txt');
  if (! -f $indexfile) {
    print "error: missing mib_index2.txt (run mkindex)\n";
    exit(1);
  }

  # load mib_index2.txt mapping all current known MIBs
  my (%vendor_for, %oldfile_for, $currvendor);
  open(my $index, '<', $indexfile) or die $!;
  while (my $line = <$index>) {
    next if $line =~ m/^MIB Index/ or $line =~ m/^\s*$/;
    if ($line =~ m/^DIR\s+(\S+)/) {
      $currvendor = (grep {m/\S/} splitdir($1))[-1];
      next;
    }
    my ($mib, $file) = ($line =~ m/^(\S+)\s+(\S+)$/);
    $oldfile_for{$mib} = $file;
    $vendor_for{$mib} = $currvendor;
  }
  close $index;

  return (\%vendor_for, \%oldfile_for);
}
